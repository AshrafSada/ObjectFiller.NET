{"name":"Objectfiller.NET","tagline":"ObjectFiller .NET","body":"The **.NET ObjectFiller** fills the properties of your .NET objects with random data!\r\nIt has a very comfortable Fluent API.\r\nYou are able to fill object instances or you just let them create for you. \r\nIt is possible to create instances of classes which have constructors with parameters.\r\nYou can also fill properties which are a interface.\r\nThe **.NET ObjectFiller** also supports Lists and Dictionaries.\r\n\r\n##Where can i get it?\r\nEasy, you can find it at nuget! It's just one DLL!\r\n\r\n**Look here:** https://www.nuget.org/packages/Tynamix.ObjectFiller\r\n\r\n\r\n##For what do you need it?\r\n\r\nYou can use the **.NET ObjectFiller** for generating test data for your **UnitTests** or for your **DesignViewModels** in WPF or for whatever you need some random testdata.\r\nI will show you some examples how you can work with it.\r\n\r\n##Can i extend the .NET ObjectFiller\r\n\r\nThe **.NET ObjectFiller** is very flexible and easy to extend. With the help of the **FluentAPI** you can configure and extend the ObjectFiller. In the examples i will show you how to do it.\r\n\r\n##Examples\r\n\r\n###Let's start easy\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n    public string Name { get; set; }\r\n    public string LastName { get; set; }\r\n    public int Age { get; set; }\r\n    public DateTime Birthday { get; set; }\r\n}\r\n\r\npublic class HelloFiller\r\n{\r\n    public void FillPerson()\r\n    {\r\n        ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n        Person p = pFiller.Fill();\r\n    }\r\n}\r\n```\r\n\r\nNothing special, it will just create a instance of a **```Person```** and fill it with some random data.\r\n\r\n###Let's use the fluent setup API\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForType<string>(() => \"SomeString\")\r\n                .RandomizerForType<DateTime>(() => new DateTime(2014, 4, 1));\r\n            Person p = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nSo what does this do? First you say **```pFiller.Setup()```**. With **```.Setup()```** you start configure the ObjectFiller. In this example we say to the ObjectFiller: Hey ObjectFiller, whenever there will be a property of type **```string```**, just fill it with the word \"SomeString\". And when there is a **```DateTime```** set it always to 1.4.2014! Easy! Isn't it? But it will get cooler!\r\n\r\n```csharp\r\n  public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForProperty(() => \"John\", p => p.Name)\r\n                .RandomizerForProperty(new RealNamePlugin(false, true), p => p.LastName);\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nHere we say: Ok ObjectFiller, fill the property **```Name```** of a **```Person```** with the value \"John\" and fill the property **```LastName```** with some random real lastname. The **```RealNamePlugin```** is a plugin which is written for the ObjectFiller and comes with the ObjectFiller.DLL.\r\nIts also really easy to write a plugin by yourself. I will show you that later.\r\n\r\n###Ignore Properties\r\n\r\n```csharp\r\n     public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .IgnoreProperties(p => p.LastName, p => p.Name);\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nWith **```IgnoreProperties```** you can exclude properties to not generate random data for it. When we will now fill a person, all properties get filled except **```LastName```** and **```Name```**.\r\n\r\n###Setup Subtypes\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n        public Address Address { get; set; }\r\n\r\n    }\r\n\r\n    public class Address\r\n    {\r\n        public string Street { get; set; }\r\n        public string City { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForProperty(() => \"John\", x => x.Name)\r\n                .SetupFor<Address>()\r\n                .RandomizerForProperty(() => \"Dresden\", x => x.City);\r\n\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nWith **```SetupFor<T>```** you start a setup for another type. In the example above we define that the ```Name``` of the ```Person``` will be \"John\" and the ```City``` of an ```Address```-object will be \"Dresden\". **```SetupFor<T>```** takes an ```bool``` parameter. if this is set to **```true```** than all the settings which was made to the parent type will be set back to default. When its not set or false, then the setup will take the setup of the parenttype, except the settings which are made specially for this actual type.\r\n\r\n###Fill objects with constructor arguments\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public Person(Address address)\r\n        {\r\n            Address = address;\r\n        }\r\n\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n        public Address Address { get; set; }\r\n\r\n    }\r\n\r\n    public class Address\r\n    {\r\n        public string Street { get; set; }\r\n        public string City { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .IgnoreProperties(p => p.Address);\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nWith ObjectFiller.NET it is also possible to **instantiate** objects which have a **constructor WITH parameters**. \r\nIn the setup i ignore the property **```Address```** of the person because it will be set in the constructor. \r\nAfter call  **```.Fill()```** the property is filled because it is set in the constructor!\r\n\r\nNow lets do something really cool.\r\n\r\n###Fill Interface-Properties\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n        public IAddress Address { get; set; }\r\n    }\r\n\r\n    public class Address : IAddress\r\n    {\r\n        public string Street { get; set; }\r\n        public string City { get; set; }\r\n    }\r\n\r\n    public interface IAddress { }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RegisterInterface<IAddress, Address>();\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nYou see? The **```Person```** has now an **```Address```**. But wait? It's an **```IAddress```**! An **interface**? \r\nYES! And ObjectFiller can handle that. Just say **```RegisterInterface```** and give the ObjectFiller the information what is the concrete implementation for that interface. Nice huh?\r\n\r\n###Fill Lists and Dictionaries\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public Dictionary<string, List<Address>> SenselessDictionary { get; set; }\r\n        public List<IAddress> SenselessList { get; set; }\r\n    }\r\n\r\n    public class Address : IAddress\r\n    {\r\n        public string Street { get; set; }\r\n        public string City { get; set; }\r\n    }\r\n\r\n    public interface IAddress {  }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RegisterInterface<IAddress, Address>();\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nIt is also really easy possible to fill **```Dictionary```** and **```Lists```** objects.\r\n\r\n###Mix all up\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public Person(IAddress address)\r\n        {\r\n            Address = address;\r\n        }\r\n        public string Name { get; set; }\r\n        public string LastName { get; set; }\r\n        public int Age { get; set; }\r\n        public DateTime Birthday { get; set; }\r\n        public IAddress Address { get; set; }\r\n\r\n        public Dictionary<string, List<Address>> SenselessDictionary { get; set; }\r\n        public List<IAddress> SenselessList { get; set; }\r\n    }\r\n\r\n    public class Address : IAddress\r\n    {\r\n        public string Street { get; set; }\r\n        public string City { get; set; }\r\n    }\r\n\r\n    public interface IAddress { }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RegisterInterface<IAddress, Address>()\r\n                .RandomizerForProperty(new RealNamePlugin(true, false), p => p.LastName, p => p.Name)\r\n                .RandomizerForProperty(() => new Random().Next(10, 32), p => p.Age)\r\n                .SetupFor<Address>()\r\n                .RandomizerForProperty(new MnemonicStringPlugin(1), a => a.City)\r\n                .IgnoreProperties(a => a.Street);\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\n**Now let us mix all up!** What happens here? Well, we say: Ok ObjectFiller, the **```IAddress```** interface will be implemented by the **```Address```** class.\r\nThe **```Name```** and **```LastName```** of a person will be generated by the **```RealNamePlugin```**. The age of the person should be something between 10 and 32. \r\nWhen you generate a city use the **```MnemonicStringPlugin```** and finally ignore the Street in the **```Address```** and don't fill it. Ok thats a lot. But it works!\r\n\r\n##Available Plugins\r\n\r\nThe ObjectFiller.NET is easy to extend and you can write your own plugins for it.\r\nThere are several plugins already implemented which are documented below.\r\n\r\n###MnemonicStringPlugin\r\n\r\nThe **```MnemonicStringPlugin```** generates mnemonic words. A mnemonic word is a word with every second letter is a vowel. For example: Dubinola\r\nThe advantage is that these words are mostly easy to pronounce.\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForType<string>(new MnemonicStringPlugin(1, 5, 10));\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nIn this example we see how to use the **```MnemonicStringPlugin```**. It has three constructor parameters. The first one defines how much words will be generated. The second is the word min length and the last one is the word max length.\r\n\r\n###RealNamePlugin\r\n\r\nThe **```RealNamePlugin```** is made to generate strings based on real names like \"Jennifer\" or \"Miller\". The realname plugin knows about 5000 First- and Lastnames. \r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForType<string>(new RealNamePlugin(true, false));\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nThe **```RealNamePlugin```** has up to two constructor parameters. They define if you want to generate a FirstName, a LastName or the FullName\r\n\r\n###RandomListItem - Plugin\r\n\r\nThe **```RandomListItem```** plugin is usefull when you want to setup a predefined set of values which are possible to use. The **```RandomListItem```** will pick a random one.\r\n\r\n```csharp\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            List<string> allNames = new List<string>() { \"Jennifer\", \"Jenny\", \"Tom\", \"John\" };\r\n\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForType<string>(new RandomListItem<string>(allNames));\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\nIn the example u can see that i set up four names. One of these will be the name of the **```Person```** object.\r\n\r\n###Write your own plugin\r\n\r\nTo write your own plugin is very easy.\r\nJust implement the **``` IRandomizerPlugin<T> ```** plugin. The typeparamer **```T```** defines for which type you will write the plugin. The interface just has one function which you have to implement: **```T GetValue();```**\r\nThats all!\r\nYou can write plugins for simple types and complex types.\r\n\r\nHere is a very simple example:\r\n\r\n```csharp\r\n  public class MyFirstPlugin : IRandomizerPlugin<string>\r\n    {\r\n        public string GetValue()\r\n        {\r\n            List<string> allNames = new List<string>() { \"Jennifer\", \"Jenny\", \"Tom\", \"John\" };\r\n            Random r = new Random();\r\n\r\n            return allNames[r.Next(0, allNames.Count)];\r\n        }\r\n    }\r\n\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n    }\r\n\r\n    public class HelloFiller\r\n    {\r\n        public void FillPerson()\r\n        {\r\n            ObjectFiller<Person> pFiller = new ObjectFiller<Person>();\r\n            pFiller.Setup()\r\n                .RandomizerForType<string>(new MyFirstPlugin());\r\n\r\n            Person filledPerson = pFiller.Fill();\r\n        }\r\n    }\r\n```\r\n\r\n**```MyFirstPlugin```** does basically the same thing as the **```RandomListItem```**-plugin, but it is a good way to show you how easy it is to implement your own plugin.\r\n\r\n##Thank you for using ObjectFiller.NET\r\n\r\nIf you have any questions or found bugs, have ideas for improvements, feel free to contact me!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}